# Пошаговый план по интеграции веб-дашборда с ботом Firefly-BBS

Этот документ описывает последовательность шагов, необходимых для полной интеграции созданного веб-дашборда с основной логикой приложения `mesh_bot.py`.

## Фаза 1: Синхронизация данных от бота в базу данных

Цель этой фазы — заставить `mesh_bot.py` записывать все необходимые данные в базу данных SQLite (`webui/dashboard.db`), чтобы веб-интерфейс мог их отображать.

1.  **Интеграция с базой данных в `mesh_bot.py`**:
    *   В `mesh_bot.py` импортировать функции для работы с БД. Рекомендуется создать отдельный модуль-хэлпер в `webui/db_handler.py`, который будет содержать функции для записи данных (например, `add_node`, `save_message` и т.д.), чтобы не смешивать SQL-код с основной логикой бота.
    *   При инициализации бота необходимо создавать соединение с БД.

2.  **Сохранение информации об узлах (Nodes)**:
    *   В `mesh_bot.py`, в коде, который обрабатывает пакеты с информацией об узлах (например, в обработчике `onReceive` или аналогичном), добавить вызов функции для сохранения или обновления информации об узле в таблице `nodes`.
    *   Сохраняемые данные: `node_id`, `name`, `last_seen`, `battery_level`, `latitude`, `longitude`, `altitude`.

3.  **Сохранение сообщений (Messages)**:
    *   В том же обработчике `onReceive`, где обрабатываются текстовые сообщения, добавить вызов функции для сохранения каждого сообщения в таблицу `messages`.
    *   Сохраняемые данные: `from_node_id`, `to_node_id`, `channel`, `text`, `timestamp`, `is_dm`.

4.  **Сохранение сообщений форума (BBS Posts)**:
    *   Модифицировать функции, отвечающие за BBS (`bbspost`, `bbsdelete` и т.д.), чтобы они также взаимодействовали с таблицей `forum_posts` в базе данных. Это обеспечит синхронизацию между BBS в сети и веб-форумом.

## Фаза 2: Реализация API и динамического фронтенда

Цель этой фазы — создать API в `webui/main.py` для получения данных из БД и оживить страницы дашборда, чтобы они отображали реальные данные.

1.  **Создание API-эндпоинтов**:
    *   В `webui/main.py` создать новый раздел для API-маршрутов (например, с префиксом `/api/v1/`).
    *   Реализовать эндпоинты для получения данных:
        *   `GET /api/v1/nodes` — возвращает список всех узлов.
        *   `GET /api/v1/messages` — возвращает список сообщений (с пагинацией и фильтрацией).
        *   `GET /api/v1/forum/topics` — возвращает список тем на форуме.
        *   `GET /api/v1/forum/posts/{topic_id}` — возвращает сообщения для конкретной темы.
        *   `GET /api/v1/stats` — возвращает общую статистику для страницы "Сводка".
        *   И так далее для всех остальных разделов.

2.  **"Оживление" фронтенда**:
    *   Модифицировать HTML-шаблоны в `webui/templates/`.
    *   Использовать JavaScript (например, с помощью `fetch` API) для обращения к созданным API-эндпоинтам при загрузке страницы.
    *   Наполнять страницы данными, полученными от API. Например, на странице "Ноды" отрисовывать таблицу с узлами.
    *   Реализовать периодическое обновление данных (например, каждые 5-10 секунд), чтобы дашборд был "живым".

3.  **Реализация интерактивной карты**:
    *   Интегрировать библиотеку для работы с картами, например, [Leaflet.js](https://leafletjs.com/).
    *   На странице `map.html` создать карту.
    *   С помощью JS запрашивать эндпоинт `/api/v1/nodes`, получать координаты и отображать маркеры узлов на карте.
    *   Добавить автоматическое обновление позиций на карте.

## Фаза 3: Реализация интерактивного взаимодействия (от дашборда к боту)

Цель этой фазы — дать пользователям возможность управлять ботом и сетью через веб-интерфейс.

1.  **Создание механизма команд**:
    *   Реализовать механизм для отправки команд из веб-интерфейса в `mesh_bot.py`. Возможные решения:
        *   **Через базу данных**: Веб-интерфейс создает запись в специальной таблице `commands_queue`, а `mesh_bot.py` периодически проверяет эту таблицу и выполняет команды.
        *   **Через API самого бота**: Добавить в `mesh_bot.py` легковесный HTTP-сервер (например, на `http.server`), который будет слушать на локальном порту и принимать команды от `webui`.
    *   Выбранный механизм должен быть безопасным, чтобы предотвратить несанкционированное выполнение команд.

2.  **Реализация отправки сообщений**:
    *   На странице "Сообщения" добавить форму для отправки нового сообщения.
    *   При отправке формы, JS должен отправлять запрос на API-эндпоинт в `webui` (например, `POST /api/v1/messages/send`).
    *   Этот эндпоинт, в свою очередь, использует механизм команд (см. п.1) для того, чтобы `mesh_bot.py` отправил сообщение в сеть.

3.  **Управление гео-зонами и триггерами**:
    *   Реализовать полный CRUD (Create, Read, Update, Delete) для гео-зон и триггеров через API и веб-интерфейс.
    *   `mesh_bot.py` должен будет при старте загружать все активные зоны и триггеры из БД в свою память и использовать их в своей логике (например, при проверке местоположения узлов).

4.  **Управление пользователями и настройками**:
    *   Реализовать систему регистрации и авторизации для дашборда. Пароли должны храниться в виде хэшей (например, с использованием `passlib`).
    *   На странице "Настройки" реализовать возможность изменять конфигурацию, которая будет сохраняться либо в `config.ini` (требует осторожного подхода к записи файлов), либо в специальной таблице в БД.

## Необходимые зависимости

В процессе реализации могут понадобиться следующие библиотеки:

*   **Python**:
    *   `passlib[bcrypt]` — для хэширования паролей.
    *   `uvicorn[standard]` — уже используется, но стоит убедиться, что установлена полная версия для лучшей производительности.
*   **JavaScript (Frontend)**:
    *   [Leaflet.js](https://leafletjs.com/) — для интерактивной карты.
    *   Возможно, легковесный фреймворк типа [Alpine.js](https://alpinejs.dev/) или [htmx](https://htmx.org/) для упрощения динамического обновления контента.

Этот план представляет собой общую дорожную карту. Каждый шаг потребует детальной проработки и аккуратной реализации. Удачи!