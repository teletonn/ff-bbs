{% extends "base.html" %}

{% block content %}
<div id="loading" class="loading">Loading messages...</div>
<div class="filter-panel">
    <select id="filter-type" onchange="updateFilterPlaceholder()">
        <option value="from_id">–û—Ç (ID –∏–ª–∏ –∏–º—è)</option>
        <option value="channel">–ö–∞–Ω–∞–ª</option>
        <option value="dm">–¢–æ–ª—å–∫–æ –õ–°</option>
        <option value="channel_only">–¢–æ–ª—å–∫–æ –∫–∞–Ω–∞–ª</option>
    </select>
    <input type="text" id="filter-input" placeholder="–§–∏–ª—å—Ç—Ä –ø–æ –æ—Ç–ø—Ä–∞–≤–∏—Ç–µ–ª—é" oninput="debouncedFilter()">
    <button onclick="applyFilter()">–§–∏–ª—å—Ç—Ä</button>
    <button onclick="clearFilter()">–û—á–∏—Å—Ç–∏—Ç—å</button>
    <button onclick="refreshMessages()">–û–±–Ω–æ–≤–∏—Ç—å</button>
</div>

<div class="control-panel">
   <h3>–û—Ç–ø—Ä–∞–≤–∏—Ç—å –Ω–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ</h3>
   <label for="recipient-select">–ü–æ–ª—É—á–∞—Ç–µ–ª—å:</label><br>
   <select id="recipient-select"><option value="">–í—ã–±–µ—Ä–∏—Ç–µ –ø–æ–ª—É—á–∞—Ç–µ–ª—è</option></select><br>
   <label for="message-input">–°–æ–æ–±—â–µ–Ω–∏–µ (–º–∞–∫—Å 500 —Å–∏–º–≤–æ–ª–æ–≤):</label><br>
   <textarea id="message-input" placeholder="–í–≤–µ–¥–∏—Ç–µ –≤–∞—à–µ —Å–æ–æ–±—â–µ–Ω–∏–µ" maxlength="500" required></textarea><br>
   <button onclick="sendMessage()">–û—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ</button>
</div>
<div id="messages-container" style="display: none;">
    <!-- Message cards will be inserted here -->
</div>
<div id="no-messages" class="loading" style="display: none;">–°–æ–æ–±—â–µ–Ω–∏—è –Ω–µ–¥–æ—Å—Ç—É–ø–Ω—ã</div>
<div id="pagination" class="pagination">
  <button id="prev-btn" onclick="changePage(-1)" disabled>–ü—Ä–µ–¥—ã–¥—É—â–∞—è</button>
  <span id="page-info" class="page-info">–°—Ç—Ä–∞–Ω–∏—Ü–∞ 1</span>
  <button id="next-btn" onclick="changePage(1)" disabled>–°–ª–µ–¥—É—é—â–∞—è</button>
</div>
<div id="error" class="error" style="display: none;">–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏–π</div>

<!-- Success Modal -->
<div id="success-modal" class="modal">
  <div class="modal-content">
    <span class="close" onclick="closeModal()">&times;</span>
    <h3>–°–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ —É—Å–ø–µ—à–Ω–æ!</h3>
    <p id="success-message"></p>
  </div>
</div>

<script>
let currentPage = 1;
let currentFilter = '';
let currentFilterType = 'from_id';
let totalPages = 1;
let channels = [];
let users = [];
let nodes = [];
let filterTimeout = null;
let websocket = null;
let websocketReconnectAttempts = 0;
let websocketReconnectTimeout = null;
let maxWebSocketReconnectAttempts = 10;

const channelMapping = {
  'üåûFireFly': 0,
  'üåçHOME': 1,
  // Add more channel mappings as needed
};

// Debounced filter function
function debouncedFilter() {
    clearTimeout(filterTimeout);
    filterTimeout = setTimeout(() => {
        applyFilter();
    }, 300); // 300ms delay
}

function loadDropdowns() {
   Promise.all([
     fetch('/api/v1/channels').then(res => res.json()),
     fetch('/api/v1/users').then(res => res.json()),
     fetch('/api/v1/nodes').then(res => res.json())
   ])
   .then(([chData, userData, nodeData]) => {
     channels = chData;
     // Add default channels if not present
     const defaultChannels = ['0', '1', '2', '3', '4', '5', '6', '7'];
     defaultChannels.forEach(ch => {
       if (!channels.includes(ch)) {
         channels.push(ch);
       }
     });
     users = userData;
     nodes = nodeData;
     updateRecipients();
   })
   .catch(err => console.error('Error loading data:', err));
}

function updateRecipients() {
     const recipientSelect = document.getElementById('recipient-select');
     recipientSelect.innerHTML = '<option value="">–í—ã–±–µ—Ä–∏—Ç–µ –ø–æ–ª—É—á–∞—Ç–µ–ª—è</option>';

    // Add users
    users.forEach(user => {
      if (user.node_id) {
        const option = document.createElement('option');
        option.value = "user:" + user.node_id;
        option.textContent = `${user.username} (–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å)`;
        recipientSelect.appendChild(option);
      }
    });

    // Add nodes
    nodes.forEach(node => {
      const option = document.createElement('option');
      option.value = "node:" + node.id;
      option.textContent = `${node.name || node.id} (–£–∑–µ–ª)`;
      recipientSelect.appendChild(option);
    });

    // Add channels
    channels.forEach(ch => {
      let index, displayName;
      if (channelMapping[ch] !== undefined) {
        index = channelMapping[ch];
        displayName = ch;
      } else {
        index = parseInt(ch) || 0;
        displayName = ch;
      }
      const option = document.createElement('option');
      option.value = "channel:" + index.toString();
      option.textContent = `${displayName} (–ö–∞–Ω–∞–ª)`;
      recipientSelect.appendChild(option);
    });
}


function updateFilterPlaceholder() {
    const filterType = document.getElementById('filter-type').value;
    const filterInput = document.getElementById('filter-input');
    currentFilterType = filterType;
    if (filterType === 'dm') {
      filterInput.style.display = 'none';
      filterInput.value = '';
    } else if (filterType === 'channel_only') {
      filterInput.style.display = 'none';
      filterInput.value = '';
    } else {
      filterInput.style.display = 'inline-block';
      const placeholders = {
        'from_id': '–§–∏–ª—å—Ç—Ä –ø–æ –æ—Ç–ø—Ä–∞–≤–∏—Ç–µ–ª—é (ID –∏–ª–∏ –∏–º—è)',
        'channel': '–§–∏–ª—å—Ç—Ä –ø–æ –∫–∞–Ω–∞–ª—É'
      };
      filterInput.placeholder = placeholders[filterType] || `–§–∏–ª—å—Ç—Ä –ø–æ ${filterType}`;
    }
}

function createMessageCard(msg) {
    const card = document.createElement('div');
    card.className = 'message-card';

    // Determine status based on status field
    let statusText = '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ';
    let statusClass = 'status-unknown';
    const status = msg.status;
    if (status === 'delivered') {
        statusText = '–î–æ—Å—Ç–∞–≤–ª–µ–Ω–æ';
        statusClass = 'status-delivered';
    } else if (status === 'queued') {
        statusText = '–û–∂–∏–¥–∞–µ—Ç';
        statusClass = 'status-pending';
    } else if (status === 'undelivered') {
        statusText = '–ù–µ –¥–æ—Å—Ç–∞–≤–ª–µ–Ω–æ';
        statusClass = 'status-undelivered';
    } else if (status === 'failed') {
        statusText = '–û—à–∏–±–∫–∞ –¥–æ—Å—Ç–∞–≤–∫–∏';
        statusClass = 'status-failed';
    } else if (status === 'sent') {
        statusText = '–û—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ';
        statusClass = 'status-pending';
    }

    // Format display names
    const fromDisplay = msg.from_name || msg.from_id || '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ';
    const toDisplay = msg.to_name || msg.to_id || '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ';

    // Determine if retry button should be enabled
    const canRetry = status === 'queued' || status === 'undelivered' || status === 'failed';
    const retryButtonDisabled = canRetry ? '' : 'disabled';

    card.innerHTML = `
        <div class="message-header" onclick="toggleMessageCard(this)">
            <div class="message-info">
                <span class="message-type">${msg.is_dm ? '–õ–°' : '–ö–∞–Ω–∞–ª'}</span>
                <span class="from-to">–û—Ç: ${fromDisplay} ‚Üí –ö–æ–º—É: ${toDisplay}</span>
                <span class="channel">${msg.channel || ''}</span>
            </div>
            <div class="message-meta">
                <span class="timestamp">${msg.timestamp || ''}</span>
                <span class="status ${statusClass}">${statusText}</span>
                <span class="expand-icon">‚ñº</span>
            </div>
        </div>
        <div class="message-content">
            <div class="message-text">${msg.text || ''}</div>
        </div>
        <div class="message-details" style="display: none;">
            <div class="detail-row">
                <strong>–û—Ç ID:</strong> ${msg.from_id || 'N/A'}
            </div>
            <div class="detail-row">
                <strong>–ö–æ–º—É ID:</strong> ${msg.to_id || 'N/A'}
            </div>
            <div class="detail-row">
                <strong>–ö–∞–Ω–∞–ª:</strong> ${msg.channel || 'N/A'}
            </div>
            <div class="detail-row">
                <strong>–í—Ä–µ–º—è:</strong> ${msg.timestamp || 'N/A'}
            </div>
            <div class="detail-row">
                <strong>–°—Ç–∞—Ç—É—Å –¥–æ—Å—Ç–∞–≤–∫–∏:</strong> ${statusText}
            </div>
            <div class="detail-row">
                <strong>–ü–æ–ø—ã—Ç–æ–∫ –¥–æ—Å—Ç–∞–≤–∫–∏:</strong> ${msg.attempt_count || 0}
            </div>
            <div class="detail-row">
                <strong>–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ–≤—Ç–æ—Ä–æ–≤:</strong> ${msg.defer_count || 0}
            </div>
            <div class="message-actions">
                <button onclick="retryMessage(${msg.id})" ${retryButtonDisabled}>–ü–æ–≤—Ç–æ—Ä–∏—Ç—å –æ—Ç–ø—Ä–∞–≤–∫—É</button>
                <button onclick="deleteMessage(${msg.id})">–£–¥–∞–ª–∏—Ç—å</button>
            </div>
        </div>
    `;

    return card;
}

function toggleMessageCard(header) {
    const card = header.parentElement;
    const details = card.querySelector('.message-details');
    const icon = header.querySelector('.expand-icon');

    if (details.style.display === 'none') {
        details.style.display = 'block';
        icon.textContent = '‚ñ≤';
    } else {
        details.style.display = 'none';
        icon.textContent = '‚ñº';
    }
}

function loadMessages(page = 1, filter = '', filterType = 'from_id') {
    document.getElementById('loading').style.display = 'block';
    document.getElementById('messages-container').style.display = 'none';
    document.getElementById('no-messages').style.display = 'none';
    document.getElementById('error').style.display = 'none';

    // Save current scroll position
    const container = document.getElementById('messages-container');
    const scrollTop = container.scrollTop;

    let url = `/api/v1/messages?page=${page}&limit=20`;
    if (filter && filterType !== 'dm' && filterType !== 'channel_only') {
      if (filterType === 'from_id') url += `&source=${encodeURIComponent(filter)}`;
      else if (filterType === 'channel') url += `&type=${encodeURIComponent(filter)}`;
    } else if (filterType === 'dm') {
      url += `&dm_only=true`;
    } else if (filterType === 'channel_only') {
      url += `&channel_only=true`;
    }

    fetch(url)
      .then(res => {
        if (!res.ok) throw new Error(`HTTP ${res.status}: –ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏—è`);
        return res.json();
      })
      .then(data => {
        container.innerHTML = '';
        if (data.length === 0) {
          document.getElementById('no-messages').style.display = 'block';
        } else {
          // Prepend messages in reverse order to show newest at top
          for (let i = data.length - 1; i >= 0; i--) {
            const msg = data[i];
            const card = createMessageCard(msg);
            container.insertBefore(card, container.firstChild);
          }
          document.getElementById('messages-container').style.display = 'block';
          // Restore scroll position
          container.scrollTop = scrollTop;
        }
        document.getElementById('next-btn').disabled = data.length < 20;
        document.getElementById('prev-btn').disabled = page === 1;
        document.getElementById('page-info').textContent = `–°—Ç—Ä–∞–Ω–∏—Ü–∞ ${page}`;
        currentPage = page;
        currentFilter = filter;
        currentFilterType = filterType;
        document.getElementById('loading').style.display = 'none';
      })
      .catch(err => {
        console.error('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏–π:', err);
        document.getElementById('error').textContent = '–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏–π: ' + err.message;
        document.getElementById('error').style.display = 'block';
        document.getElementById('loading').style.display = 'none';
      });
}

function changePage(delta) {
   const newPage = currentPage + delta;
   if (newPage >= 1) {
     loadMessages(newPage, currentFilter, currentFilterType);
   }
}

function applyFilter() {
   const filterType = document.getElementById('filter-type').value;
   const filter = document.getElementById('filter-input').value;
   loadMessages(1, filter, filterType);
}

function clearFilter() {
     document.getElementById('filter-input').value = '';
     document.getElementById('filter-type').value = 'from_id';
     currentFilter = '';
     currentFilterType = 'from_id';
     updateFilterPlaceholder();
     loadMessages(1);
 }

function refreshMessages() {
    loadMessages(currentPage, currentFilter, currentFilterType);
}

function showSuccessModal(message) {
    document.getElementById('success-message').textContent = message;
    document.getElementById('success-modal').style.display = 'block';
}

function closeModal() {
    document.getElementById('success-modal').style.display = 'none';
}

// Close modal when clicking outside of it
window.onclick = function(event) {
    const modal = document.getElementById('success-modal');
    if (event.target == modal) {
        modal.style.display = 'none';
    }
}

function sendMessage() {
     const recipient = document.getElementById('recipient-select').value;
     const message = document.getElementById('message-input').value.trim();

     if (!recipient || !message) {
       alert('–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –∑–∞–ø–æ–ª–Ω–∏—Ç–µ –≤—Å–µ –ø–æ–ª—è.');
       return;
     }

     if (message.length > 500) {
       alert('–°–æ–æ–±—â–µ–Ω–∏–µ –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –Ω–µ –±–æ–ª–µ–µ 500 —Å–∏–º–≤–æ–ª–æ–≤.');
       return;
     }

     const parts = recipient.split(':');
     const type = parts[0];
     const value = parts[1];
     const mode = type === 'channel' ? 'channel' : 'dm';

     fetch('/api/v1/messages/send', {
       method: 'POST',
       headers: {
         'Content-Type': 'application/json',
       },
       body: JSON.stringify({ mode: mode, recipient: recipient, message: message }),
       credentials: 'same-origin'
     })
    .then(response => {
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      return response.json();
    })
    .then(data => {
      if (data.success) {
        showSuccessModal(`ID –∫–æ–º–∞–Ω–¥—ã: ${data.command_id}`);
        document.getElementById('message-input').value = '';
        loadMessages(currentPage, currentFilter, currentFilterType);
      } else {
        alert(`–û—à–∏–±–∫–∞: ${data.error || '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞'}`);
      }
    })
    .catch(error => {
      console.error('–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è:', error);
      alert(`–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è: ${error.message}`);
    });
}

function retryMessage(messageId) {
    fetch(`/api/v1/messages/${messageId}/retry`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        credentials: 'same-origin'
    })
    .then(response => {
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        return response.json();
    })
    .then(data => {
        if (data.success) {
            showSuccessModal('–°–æ–æ–±—â–µ–Ω–∏–µ –ø–æ—Å—Ç–∞–≤–ª–µ–Ω–æ –≤ –æ—á–µ—Ä–µ–¥—å –Ω–∞ –ø–æ–≤—Ç–æ—Ä–Ω—É—é –æ—Ç–ø—Ä–∞–≤–∫—É');
            loadMessages(currentPage, currentFilter, currentFilterType);
        } else {
            alert(`–û—à–∏–±–∫–∞: ${data.error || '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞'}`);
        }
    })
    .catch(error => {
        console.error('–û—à–∏–±–∫–∞ –ø–æ–≤—Ç–æ—Ä–Ω–æ–π –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è:', error);
        alert(`–û—à–∏–±–∫–∞ –ø–æ–≤—Ç–æ—Ä–Ω–æ–π –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è: ${error.message}`);
    });
}

function deleteMessage(messageId) {
    if (!confirm('–í—ã —É–≤–µ—Ä–µ–Ω—ã, —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ —É–¥–∞–ª–∏—Ç—å —ç—Ç–æ —Å–æ–æ–±—â–µ–Ω–∏–µ?')) {
        return;
    }

    fetch(`/api/v1/messages/${messageId}`, {
        method: 'DELETE',
        headers: {
            'Content-Type': 'application/json',
        },
        credentials: 'same-origin'
    })
    .then(response => {
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        return response.json();
    })
    .then(data => {
        if (data.success) {
            showSuccessModal('–°–æ–æ–±—â–µ–Ω–∏–µ —É–¥–∞–ª–µ–Ω–æ');
            loadMessages(currentPage, currentFilter, currentFilterType);
        } else {
            alert(`–û—à–∏–±–∫–∞: ${data.error || '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞'}`);
        }
    })
    .catch(error => {
        console.error('–û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è —Å–æ–æ–±—â–µ–Ω–∏—è:', error);
        alert(`–û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è —Å–æ–æ–±—â–µ–Ω–∏—è: ${error.message}`);
    });
}

function connectWebSocket() {
    // Clear any existing reconnection timeout
    if (websocketReconnectTimeout) {
        clearTimeout(websocketReconnectTimeout);
        websocketReconnectTimeout = null;
    }

    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
    const wsUrl = `${protocol}//${window.location.host}/ws/map`;

    websocket = new WebSocket(wsUrl);

    websocket.onopen = function(event) {
        console.log('WebSocket connected for message updates');
        websocketReconnectAttempts = 0;
    };

    websocket.onmessage = function(event) {
        try {
            const data = JSON.parse(event.data);
            handleMessageUpdate(data);
        } catch (error) {
            console.error('Error parsing WebSocket message:', error);
        }
    };

    websocket.onclose = function(event) {
        console.log('WebSocket disconnected, code:', event.code, 'reason:', event.reason);

        // Don't reconnect if it was a clean close (code 1000) or if max attempts reached
        if (event.code === 1000 || websocketReconnectAttempts >= maxWebSocketReconnectAttempts) {
            console.log('WebSocket connection permanently closed or max reconnection attempts reached');
            return;
        }

        websocketReconnectAttempts++;

        // Exponential backoff: base delay of 1 second, doubling each attempt, max 60 seconds
        const delay = Math.min(1000 * Math.pow(2, websocketReconnectAttempts - 1), 60000);

        console.log(`Attempting to reconnect WebSocket in ${delay}ms (attempt ${websocketReconnectAttempts}/${maxWebSocketReconnectAttempts})`);

        websocketReconnectTimeout = setTimeout(() => {
            connectWebSocket();
        }, delay);
    };

    websocket.onerror = function(error) {
        console.error('WebSocket error:', error);
        // Don't show error here as onclose will handle reconnection
    };
}

function disconnectWebSocket() {
    if (websocket) {
        websocket.close(1000, 'Client disconnecting');
        websocket = null;
    }
    if (websocketReconnectTimeout) {
        clearTimeout(websocketReconnectTimeout);
        websocketReconnectTimeout = null;
    }
    websocketReconnectAttempts = 0;
}

function handleMessageUpdate(update) {
    console.log('Received message update:', update);

    if (update.type === 'message_status') {
        // Update message status in real-time
        updateMessageStatus(update.data);
    }
}

function updateMessageStatus(data) {
    // Find the message card and update its status
    const messageCards = document.querySelectorAll('.message-card');
    messageCards.forEach(card => {
        const messageId = card.querySelector('button[onclick*="retryMessage"]')?.getAttribute('onclick')?.match(/retryMessage\((\d+)\)/)?.[1];
        if (messageId && data.message_id == messageId) {
            // Update the status display
            const statusSpan = card.querySelector('.status');
            if (statusSpan && data.status) {
                let statusText = '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ';
                let statusClass = 'status-unknown';
                const status = data.status;
                if (status === 'delivered') {
                    statusText = '–î–æ—Å—Ç–∞–≤–ª–µ–Ω–æ';
                    statusClass = 'status-delivered';
                } else if (status === 'queued') {
                    statusText = '–û–∂–∏–¥–∞–µ—Ç';
                    statusClass = 'status-pending';
                } else if (status === 'undelivered') {
                    statusText = '–ù–µ –¥–æ—Å—Ç–∞–≤–ª–µ–Ω–æ';
                    statusClass = 'status-undelivered';
                } else if (status === 'failed') {
                    statusText = '–û—à–∏–±–∫–∞ –¥–æ—Å—Ç–∞–≤–∫–∏';
                    statusClass = 'status-failed';
                } else if (status === 'sent') {
                    statusText = '–û—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ';
                    statusClass = 'status-pending';
                }

                statusSpan.className = `status ${statusClass}`;
                statusSpan.textContent = statusText;

                // Update retry button state
                const retryButton = card.querySelector('button[onclick*="retryMessage"]');
                if (retryButton) {
                    const canRetry = status === 'queued' || status === 'undelivered' || status === 'failed';
                    retryButton.disabled = !canRetry;
                }

                console.log(`Updated status for message ${data.message_id}: ${statusText}`);
            }
        }
    });
}

loadDropdowns();
loadMessages();
connectWebSocket();
setInterval(() => loadMessages(currentPage, currentFilter, currentFilterType), 30000);

// Cleanup on page unload
window.addEventListener('beforeunload', function() {
    disconnectWebSocket();
});
</script>
{% endblock %}